\section{Реализация}
	
	За постигане на целите на описаната система може да се подходи по различни начини (както и към повечето софтуерни проблеми), но естеството на проблема и незнанието от страна на автора за пълна спецификация на крайния продукт са предпоставки за използване на \ac{AD}.
	
	\ac{AD} е процес, съвкупност от множество практики при разработка на софтуер. Той позволява изучаване на областта, за която се създава продукта, доставя частични работещи версии през определен период от време (най-често на всеки две седмици) и насърчава бързата реакция при настъпване на промени. Терминът е представен от \emph{The Agile Manifesto}\footnote{\url{http://agilemanifesto.org/}} през 2001 г.
	
	\ac{AD} предоставя начини за справяне с проблемите при създаване на софтуерни продукти, но оставя и свобода за персонализиране за съответната среда и разработчици.
	
	\subsection{Процес за реализация на системата}
	
		Предлага се следния персонализиран вариант на \ac{AD} за създаване на системата. Необходимо е извършването на няколко повторения(iterations). За всяко от тях:
	
		\begin{itemize}
			\item Избиране на 2-3 свойства за добавяне към съществуващия продукт от общия списък.
			\item За всяко от тях:
				\begin{itemize}
					\item Създават се тестове, които да покажат, че част от свойството работи
					\item Имплементира се логиката необходима за преминаване на тестовете
					\item Кодът се преглежда за начини за промяна с цел улесняване за промяна и по-лесно разбиране
					\item Повтаря се, докато свойството не е напълно имплементирано
				\end{itemize}
			\item Пускат се всички тестове
			\item Преглед и обсъждане на възможности за подобряване на проекта
			\item Текущата версия е готова
		\end{itemize}
		
	\subsection{Повторение I}
	
		За първото повторение от имплементацията на системата се избират най-важните свойства от нея:
		
		\begin{itemize}
			\item Извличане на информация за приложение и запазването й
			\item Регистрация на потребители
			\item Създаване и запазване на препоръки
		\end{itemize}
		
		За извличане на информация за отделните приложения съществуват множество от уеб страници, две от които са \url{http://play.google.com/} и \url{http://www.appannie.com/}. Вторият предоставя допълнителна информация, като например ранкът на приложението в различните държави, което може да се окаже предимство при по-задълбочен анализ на всяко приложение.
		
		Създават се тестове, които проверяват дали се взима правилната информация от AppAnnie, като заглавие, описание, категория и т.н. за всяко приложение. Оптимизация, която намаля значително времето за изпълнение на тестовете, е запазване на съдържанието на страницата, която се тества, върху диска на компютъра. Това има един сериозен недостатък - при промяна на страницата, тестовете ще продължат да преминават, тъй като имат стара версия на съдържанието. Този проблем се решава лесно като съдържанието се обновява често ръчно или автоматично.
		
		На фигура ~\ref{figure:spider} е показана клас диаграма на модула \emph{Spider}. Основния клас в него е \emph{AppAnnieSpider}. Той наследява \emph{BaseSpider} от библиотеката \emph{Scrapy} и предоставя основната функционалност за обработка на данните от уеб страницата. Това става чрез задаване на конкретни \emph{XPath}\footnote{\url{http://www.w3.org/TR/xpath/}} изрази. В следващи версии на библиотеката ще е възможно и използването на \emph{CSS}\footnote{\url{http://www.w3.org/TR/CSS2/selector.html}} изрази.
		
		\emph{AppPipeline} отново наследява базов клас от \emph{Scrapy} и неговата цел е да предостави възможност за обработка на обектите, които са извлечени, паралелно. Тук се случва и самото запазване на информацията в базата от данни. \emph{AppItem} има за цел да да съхрани информация за приложение.
		
		\begin{figure}[htbp]
			\centering
 			\includegraphics[scale=1.3]{diagrams/spider.1}
			\caption{Клас диаграма на Spider}
			\label{figure:spider}
		\end{figure}
		
		Регистрацията на потребител се състой в събиране и запазване на информация, подадена от клиента. По-ясен поглед върху класа, представляваш потребител, се намира в общия модел на фигура ~\ref{figure:model}
		
		Създаването на добри предложения е това, което показва колко успешна е имплементацията. \ac{CF} предоставя добър подход за решаването на такъв проблем, но оставя голяма част от детайлите да бъдат разгледани от разработчика.
		Това прави писането на тестове още по-важно, защото те позволяват налагане на бързи подобрения, ако бъде намерено ново, по-добро, решение.
		
		\subsubsection{Избор на метрика за сходство}
		
		Запазване на предложенията е лесно, благодарение на общия модел на системата.